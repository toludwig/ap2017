
numberP :: Parser Expr
numberP = negP
       <|> posP

posP :: Parser Expr
posP = do
  ns <- many1 digit
  if (length ns < 9)
    then return (Number (read ns))
    else fail "Number too long"

negP :: Parser Expr
negP = do
  x <- string "-"
  ns <- many1 digit
  if (length ns < 9)
    then return (Number (read (x ++ ns)))
    else fail "Number too long"



--- old version

stringP :: Parser Expr
stringP = do
  string "'" -- start of string
  c <- manyTill substringP (string "'") -- end of string reached, PROBLEM: escaped single quote
  return (String (concat c))

substringP :: Parser String
substringP = do
  c1 <- anyChar
  if (ord c1 == 47) then -- ascii for backslash
    do
    c2 <- anyChar
    case (ord c2) of
      13  -> return ""   -- ascii for carriage return
      47  -> return "\\" -- ascii for backslash
      39  -> return "'"  -- ascii for '
      110 -> return "\n" -- ascii for n
      116 -> return "\t" -- ascii for t
      otherwise -> fail "unknown escape sequence"
  else return [c1]



  ---- new Version


stringP :: Parser Expr
stringP = do
  string "'" -- start of string
  c <- many (try substringP)
  string "'" -- end of string
  return (String (concat c))

substringP :: Parser String
substringP = do
  c1 <- anyChar
  case [c1] of
    "'"  -> fail "eos"   -- end of string reached
    "\\" -> do           -- single backslash escapes the next char
        c2 <- anyChar    -- which requires reading
        case c2 of
          '\n' -> return ""
          '\\' -> return "\\"
          '\'' -> return "'"
          'n'  -> return "\n"
          't'  -> return "\t"
          _    -> return "unknown escape sequence"

    _ -> return [c1]    -- otherwise, just return the char

-- Toms test clipboard

testIdentP s =
  identGood s ==> case parse identP "" s of
    Right s' -> (s==s')
    Left e   -> False

identGood s = (s/= []) && C.isLetter (head s) && ((all (\c -> C.isAlphaNum c || (c == '_')) (tail s)) || (tail s == []))
